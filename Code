import threading
import time
import random
import json
import os
from collections import deque

# CONFIG BASE
MAX_RESCUERS = 30
MAX_FAILURES = 3
CITY_FILE = "city.json"

TIPI_ZONE = [
    "Residenziale",
    "Commerciale",
    "Industriale",
    "Turistica",
    "Sportiva"
]

LEVELS = {
    "bianco": {"people": 1, "base_time": 3, "score": 10, "severity": 1},
    "verde":  {"people": 2, "base_time": 5, "score": 20, "severity": 2},
    "giallo": {"people": 4, "base_time": 8, "score": 40, "severity": 3},
    "rosso":  {"people": 6, "base_time": 12, "score": 70, "severity": 4},
    "nero":   {"people": 8, "base_time": 18, "score": 120, "severity": 5}
}

# VARIABILI DI GIOCO
available_rescuers = MAX_RESCUERS
score = 0
failures = 0
game_over = False

lock = threading.Lock()
call_queue = deque()
active_calls = {}

CALL_INTERVAL = (3, 6)
TIME_LIMIT = 15
HARDCORE = False


# SCELTA DIFFICOLT√Ä
def choose_difficulty():
    global CALL_INTERVAL, TIME_LIMIT, HARDCORE

    print("üéÆ SCEGLI DIFFICOLT√Ä")
    print("1Ô∏è‚É£  Facile")
    print("2Ô∏è‚É£  Hardcore")

    while True:
        choice = input("> ").strip()
        if choice == "1":
            print("‚úÖ Modalit√† FACILE\n")
            return
        if choice == "2":
            HARDCORE = True
            CALL_INTERVAL = (1, 2)
            TIME_LIMIT = 5
            print("üî• MODALIT√Ä HARDCORE üî•\n")
            return
        print("‚ùå Scelta non valida")


# CITT√Ä 
def create_city():
    zones = [{"id": i, "name": f"Zona {i}", "tipo": random.choice(TIPI_ZONE), "active": False}
             for i in range(1, 26)]
    with open(CITY_FILE, "w") as f:
        json.dump({"zones": zones}, f, indent=4)


def load_city():
    if not os.path.exists(CITY_FILE):
        create_city()
    with open(CITY_FILE) as f:
        return json.load(f)


def save_city(city):
    with open(CITY_FILE, "w") as f:
        json.dump(city, f, indent=4)


# THREAD INTERVENTO 
class Intervention(threading.Thread):
    def __init__(self, call):
        super().__init__()
        self.call = call

    def run(self):
        global available_rescuers, score, game_over

        time.sleep(self.call["duration"])

        with lock:
            if game_over:
                return

            available_rescuers += self.call["people"]
            score += self.call["score"]
            self.call["zone"]["active"] = False
            # NESSUNA STAMPA


# TIMER CHIAMATA
class CallTimer(threading.Thread):
    def __init__(self, call_id):
        super().__init__(daemon=True)
        self.call_id = call_id

    def run(self):
        global failures, game_over

        time.sleep(TIME_LIMIT)

        with lock:
            if game_over:
                return

            if self.call_id in active_calls:
                call = active_calls.pop(self.call_id)
                failures += 1
                call["zone"]["active"] = False

                if failures >= MAX_FAILURES:
                    game_over = True
                    print("\nüíÄ GAME OVER üíÄ")
                    print(f"PUNTEGGIO FINALE: {score}")
                    os._exit(0)


# GENERATORE CHIAMATE
def call_generator(city):
    while True:
        time.sleep(random.randint(*CALL_INTERVAL))

        if game_over:
            return

        free_zones = [z for z in city["zones"] if not z["active"]]
        if not free_zones:
            continue

        zone = random.choice(free_zones)
        zone["active"] = True
        level = random.choice(list(LEVELS.keys()))
        cid = random.randint(1000, 9999)

        if HARDCORE:
            duration = 5 + (LEVELS[level]["severity"] * 3)
        else:
            duration = LEVELS[level]["base_time"]

        call = {
            "id": cid,
            "zone": zone,
            "level": level,
            "people": LEVELS[level]["people"],
            "duration": duration,
            "score": LEVELS[level]["score"],
            "arrival": time.time()
        }

        with lock:
            call_queue.append(call)
            active_calls[cid] = call

        CallTimer(cid).start()


# GESTIONE UTENTE
def handle_call(call):
    global available_rescuers, failures, game_over

    elapsed = int(time.time() - call["arrival"])
    remaining = max(0, TIME_LIMIT - elapsed)

    if remaining <= 0 or game_over:
        return

    print("\nüìû CHIAMATA IN LINEA")
    print(f"ID: {call['id']}")
    print(f"Zona: {call['zone']['name']}")
    print(f"Tipo: {call['zone']['tipo']}")
    print(f"Livello: {call['level'].upper()}")
    print(f"Soccorsi richiesti: {call['people']}")
    print(f"üë• Soccorritori disponibili: {available_rescuers}")
    print(f"‚è±Ô∏è Tempo rimanente: {remaining} secondi")
    print("Rispondere? (s / n)")

    start = time.time()

    while time.time() - start < remaining:
        cmd = input("> ").lower()

        with lock:
            if game_over or call["id"] not in active_calls:
                return

            if cmd == "n":
                failures += 1
                active_calls.pop(call["id"])
                call["zone"]["active"] = False
                break

            if cmd == "s":
                if available_rescuers < call["people"]:
                    failures += 1
                    active_calls.pop(call["id"])
                    call["zone"]["active"] = False
                    break

                available_rescuers -= call["people"]
                active_calls.pop(call["id"])
                Intervention(call).start()
                return

    if failures >= MAX_FAILURES:
        game_over = True
        print("\nüíÄ GAME OVER üíÄ")
        print(f"PUNTEGGIO FINALE: {score}")
        os._exit(0)


# MAIN 
def main():
    choose_difficulty()
    city = load_city()

    print("üéÆ RESCUE ARENA ‚Äì CENTRALE OPERATIVA")
    print(f"üë• Soccorritori iniziali: {MAX_RESCUERS}")
    print(f"‚è±Ô∏è Tempo limite chiamate: {TIME_LIMIT}s")
    print("‚ö†Ô∏è 3 fallimenti = GAME OVER\n")

    threading.Thread(target=call_generator, args=(city,), daemon=True).start()

    while not game_over:
        if call_queue:
            with lock:
                call = call_queue.popleft()
            handle_call(call)
            save_city(city)
        else:
            time.sleep(0.5)


if __name__ == "__main__":
    main()
